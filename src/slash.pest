WHITESPACE = _{  " " | "\t" | NEWLINE }
COMMENT = _{ "#" ~ (!(NEWLINE | EOI) ~ ANY)* ~ (NEWLINE | &EOI) }

word_char = _{ !(WHITESPACE | "\"" | "\\" | "|" | ">" | " " | ";" | "(" | ")" | "<" | "," | "{" | "}" | "$" ) ~ ANY }
word = @{ word_char+ }

file = { SOI ~ (block | statement | ";")* ~ EOI }
block = { "{" ~ (block | statement | ";")* ~ "}" }
statement = _{ var_declaration | function_declaration | var_assignment | indexed_var_assignment | export_statement  | for_in_statement | for_std_statement | if_statement | return_statement | break_statement | continue_statement | match_statement | function_call | chain }

chain = { command ~ pipe* ~ redirection? ~ capture? }
pipe = { "|" ~ command }
redirection = { (">" | ">>") ~ command }
capture = { "$>" ~ var_name }
command = ${ command_element ~ (command_whitespace+ ~ command_element)* ~ command_whitespace*}
command_whitespace = _{ " " | "\t" | ("\\" ~ NEWLINE) }
command_element = _{ (word | string_literal | env_var | "$(" ~ expression ~ ")") + }

for_in_statement = {
    ( "for" ~ var_name ~ "in" ~ expression ~ block ) |
    ( "for" ~ "(" ~ var_name ~ "in" ~ expression ~ ")" ~ block )
}

for_std_statement = {
    "for" ~ var_name ~ "=" ~ expression  ~ ";" ~ expression ~ ";" ~ var_assignment ~ block |
    "for" ~ "(" ~ var_name ~ "=" ~ expression  ~ ";" ~ expression ~ ";" ~ var_assignment ~ ")" ~ block
}

if_statement = { "if" ~ expression ~ (statement | block) ~ ("else" ~ "if" ~ expression ~ (statement | block))* ~ ("else"  ~ (statement | block))? }

function_declaration = { "function" ~ var_name ~ "(" ~ (var_name ~ ("," ~ var_name)*)? ~ ")" ~ block }

return_statement = { "return" ~ expression }
break_statement = { "break" }
continue_statement = { "continue" }

match_statement = { "match" ~ expression ~ "{" ~ match_term+ ~ "}" }
match_term = { "_" ~ "=>" ~ block | match_expression ~ ( "," ~ match_expression )* ~ "=>" ~ block }
match_expression = { expression ~ ( "->" ~ expression )? }

var_declaration = { "let" ~ var_name ~  "=" ~ expression  }
var_assignment = { var_name ~ "=" ~ expression }
indexed_var_assignment = { var_name ~ "[" ~ expression ~ "]" ~ "=" ~ expression }
export_statement = { "export" ~ var_name ~ ("=" ~ expression)? }
var_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | "_" | ASCII_DIGIT)* }

expression = { term ~ ( operator ~ term | indexer ~ expression ~ "]" )* }
operator = _{ add | subtract | multiply| divide | power | equals | less_than | greater_than | not_equals | and | or }
    add = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide = { "/" }
    power = { "^" }
    equals = { "==" }
    less_than = { "<" }
    greater_than = { ">" }
    not_equals = { "!=" }
    and = { "&&" }
    or = { "||" }

indexer = { "[" }

term = _{ literal | function_call |  var_name | env_var |  "(" ~ expression ~ ")" | not_expression }
not_expression = { ("!" | "not") ~ expression }
env_var = { "$" ~ var_name }
function_call = { var_name ~"(" ~ ( expression ~ ("," ~ expression)*)? ~ ")" }
literal = { numeric_literal | string_literal | list_literal | map_literal }
numeric_literal = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string_literal = @{ "\"" ~ NEWLINE? ~ string_content ~ "\"" }
list_literal = { "[" ~ ( expression ~ ( "," ~ expression )* )? ~ ","? ~ "]" }
map_literal = { "{" ~ ( map_field ~ ( "," ~ map_field )* )? ~  "}" }
map_field = _{ ( string_literal | var_name ) ~ ":" ~ expression }
string_content = { ( "\\\"" | !"\"" ~ ANY )* }